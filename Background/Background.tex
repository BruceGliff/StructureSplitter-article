\section{Разбиение структур}
\label{sec:Background}

Перед описанием алгоритма разбиения определим правила, по которым мы будем выделять части агрегатных типов для векторизации.

В стандарте C++ существует концепция скалярного типа.
% TODO: тут сослаться на стандарт C++, [basic.types.general]
Скалярными называются арифметические типы, типы перечислений, указатели и cv-квалифицрованные версии перечисленных типов.
Назовём \emph{базовым} скалярный тип, поддерживаемый данной оптимизацией.
В это множество входят также векторные типы, которых нет в C++, но которые есть в LLVM IR. 
В это множество не входят, например, указатели.
Определение сознательно является несколько нечетким, чтобы заложить возможность будущего расширения.
Алгоритм ниже не разбивает базовые типы.

Назовём \emph{примитивным} либо базовый тип либо агрегатный тип, у которого типы всех элементов одинаковы и примитивны.
Такой тип нет необходимости делить, так как объекты таких типов могут быть легко переделаны в вектора фазой aggregate lowering, которая представлена в векторном оптимизаторе IGC.

% TODO: я бы эту фразу тоже выкинул. Проблема в том, что я её не понял. Пока оставлю закомментированной.
% Примитивный тип сводится к тому типу, который последний оказался в цепочке определения примитивности типа, то есть всегда к некому базовому типу.

Целью алгоритма разбиения структур является приведение всех структур в модуле (например в модуле LLVM IR) к структурам примитивного типа с обязательным сохранением поведения исходной программы в рамках as-if rule.

Фаза разбиения структур в векторном компиляторе разрабатывалась специально для ISPC - компилятора для SPMD(single program, multiple data) модели~\cite{ISPC}.
При этом алгоритм сам по себе может быть использован в более широких классах оптимизаторов, даже не основанных на LLVM.
Оптимизация работает над LLVM модулем и должна применятся до векторизации.

Разбиение невозможно, если:
\begin{enumerate}
\item элемент структуры является указателем на другую нетривиальную структуру, в том числе на саму себя.
\item на структуру взят указатель.
\end{enumerate}

Первое ограничение появляется из-за использования версии LLVM, в которой ещё не были введены opaque указатели.
Собственноручная поддержка таких указателей приводит к сильному разрастанию получаемого модуля и невозможности применения других оптимизаций.
По этой же причине была невозможна поддержка передачи структур в пользовательские функции.
Второе ограничение связано с тем, что замена кода работы с указателем на аналогичный код с поделёнными структурами может привести к значительному увеличению количества инструкций.

\textbf{Описание алгоритма}

\textbf{Шаг 1. Сбор информации о структурах в модуле}

Для каждой структуры ставится в соответствие набор примитивных типов её элементов, а для каждого такого примитивного типа сохраняется список соответствующих элементов.
По набору примитивных типов будет проводиться деление.
Сколько таких наборов минус один, столько структур необходимо будет сгенерировать.
Соответственно, если у структуры существует только один примитивный тип, то данную структуру делить нет необходимости, так как она сама является примитивной.

\textbf{Шаг 2. Построение графа вложенности структур}

Так как элементами структуры могут быть другие структуры, то такие ситуации необходимо разрешать.
Граф строится следующим образом: вершине $A$ соответствует структура \%A.
Ребро от вершины $C$ в вершину $A$ проводится в том случае, если структура, соответствующая вершине $A$, вложена в структуру, соответствующую вершине $C$.
Назовём головой графа($Head$) вершины, которые соответствуют структурам, не вложенным ни в какие другие структуры.
Голов графа может быть как одна, так и несколько.

\textbf{Шаг 3. Обработка графа вложенности структур}

Обработка графа начинается с головы, однако деление - с самой нижней вершины.
Все нижние вершины всегда характеризуются тем, что структуры, связанные с ними содержат элементы только примитивных типов, а значит данные структуры могут быть поделены.
При обработке вершины графа возможны два варианта.
Первое - если вершина отвечает за примитивную структуру, то в делении нет необходимости и данная вершина удаляется из графа.
Второе - структура, отвечающая за вершину была поделена.
Тогда нужно заменить во всех структурах, в которые была вложена данная, все элементы, отвечающие за данную структуру, на новые элементы с поделёнными структурами.
Во время замены элементов появляются промежуточные представления структур, которые затем необходимо удалить.
После обработки вершины она удаляется, поэтому в итоге весь граф удалится.

\textbf{Шаг 4. Обработка и замена инструкций}

% TODO у этого шага нужно более общее описание без привязки к LLVM IR. Например вместо alloca можно написать ``стековый слот'', вместо getelementptr -- ``обращение к элементу агрегата'' и т.п.
Обработка и замена инструкций начинается с alloca (AI).
У этой инструкции допустимы следующие пользователи: getelementptr (GEP), bitcast и ptrtoint (PTI).
Причём getelementptr без ограничения общности, а bitcast и ptrtoint только подходящие под определённые шаблоны.
В случае bitcast единственными пользователями должны бить интринсики lifetime.start/end.
% TODO убрать зависимость от ISPC FE в описании алгоритма
В случае ptrtoint фронтенд ISPC вместо доступа к нулевому элементу структуры через getelementptr использует указатель на структуру.
Данный подход необходимо было поддерживать, поэтому в анализе ptrtoint проверяется соответствие шаблону вычисления указателя из следующих инструкций: insertelement, shufflevector, add и read/write.
В случае если результатом getelementptr является примитивный тип, то эта инструкция заменяется на эквивалентную с другим операндом и новой цепочкой индексов.
Если результатом getelementptr является уже разбитая структура, то будут сгенерированы столько новых getelementptr инструкций, на сколько структур была разбита исходная.

На рис.~\ref{fig:inst_proc} показан автомат обработки инструкций в модуле.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture} [node distance = 2.5cm, on grid]
        \node (AI) [state, initial] {$AI$};
        \node (GEP) [state, right = of AI,
                     accepting right,
                     accepting distance=1cm,
                     accepting text = {others}] {$GEP$};
        \node (PTI) [state, below right = of AI] {$PTI$};
        \node (offset) [state, right = of PTI] {$offset$};
        \node (mem) [state, right = of offset] {$mem$};
        \node (BC) [state, below = of PTI] {$bitcast$};
        \node (life) [state, right = of BC] {$lifetime$};
        
        \path [-stealth, thick]
          (AI) edge node {} (GEP)
          (AI) edge node {} (PTI)
          (AI) edge node {} (BC)
          
          (GEP) edge [loop above] node {поделённая структура} ()
          (GEP) edge node {} (PTI)
          
          (PTI) edge node {} (offset)
          (offset) edge node {} (mem)
          
          (BC) edge node {} (life);
    \end{tikzpicture}
    \caption{Автомат обработки инструкций.}
    \label{fig:inst_proc}
\end{figure}
