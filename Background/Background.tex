\section{Деление структур}
\label{sec:Background}

Перед описанием алгоритма деления определим правила, по которым будем делить структуры. Введём понятия \emph{базовый тип} - несоставной тип, который не может быть поделён, обычно является стандартным типом языка программирования. \emph{Примитивный тип} - базовый тип или тип, у которого все элементы так же являются одинаковыми примитивными типами. Такой тип так же является неделимым, так как его, либо невозможно делить, либо в этом нет необходимости. Примитивный тип сводится к тому типу, который последний оказался в цепочке определения примитивности типа, то есть всегда к некому базовому типу.

Алгоритм деления структур заключается в приведении всех структур в модуле к структурам примитивного типа, если это возможно, с заменой и добавлением инструкций на эквивалентные и сохранением исходной логики программы.

Оптимизация деления структур работает над LLVM модулем и должна применятся до векторизации. Не для всех структур есть возможность деления. Во-первых, если элемент структуры является указателем на другую делимую структуру, в том числе на саму себя. Данное ограничение появляется из-за использования версии LLVM, в которой ещё не были введены opaque указатели. Собственноручная поддержка таких указателей приводит к сильному разрастанию получаемого модуля и невозможности применения других оптимизаций. По этой же причине была невозможна поддержка передачи структур в пользовательские функции. Во-вторых, любое взятие указателя на структуру препятствует делению, так как замена кода работы с указателем на аналогичный код с поделёнными структурами может привести к значительному увеличению количества инструкций.

Для начала необходимо собрать всю информацию о структурах в модуле. Для каждой структуры ставится в соответствие набор примитивных типов её элементов, а для каждого такого примитивного типа сохраняется список соответствующих элементов. По набору примитивных типов будет проводиться деление. Сколько таких наборов минус один, столько структур необходимо будет сгенерировать. Соответственно, если у структуры существует только один примитивный тип, то данную структуру делить нет необходимости, так как она сама является примитивной.

После сбора информации о структурах, строится граф вложенности структур. Так как элементами структуры могут быть другие структуры, то такие ситуации необходимо разрешать. Граф строится следующим образом: вершине $A$ соответствует структура \%A. Ребро от вершины $C$ в вершину $A$ проводится в том случае, если структура, соответствующая вершине $A$, вложена в структуру, соответствующую вершине $C$. Назовём головой графа($Head$) вершины, которые соответствуют структурам, не вложенным ни в какие другие структуры. Голов графа может быть как одна, так и несколько.

Обработка графа начинается с головы, однако деление - с самой нижней вершины. Все нижние вершины всегда характеризуются тем, что структуры, связанные с ними содержат элементы только примитивных типов, а значит данные структуры могут быть поделены. При обработке вершины графа возможны два варианта. Первое - если вершина отвечает за примитивную структуру, то в делении нет необходимости и данная вершина удаляется из графа. Второе - структура, отвечающая за вершину была поделена. Тогда нужно заменить во всех структурах, в которые была вложена данная, все элементы, отвечающие за данную структуру, на новые элементы с поделёнными структурами. Во время замены элементов появляются промежуточные представления структур, которые затем необходимо удалить. После обработки вершины она удаляется, поэтому в итоге весь граф удалится.

Обработка и замена инструкций начинается с alloca(AI). У этой инструкции допустимы следующие пользователи: getelementptr(GEP), bitcast и ptrtoint(PTI). Причём getelementptr без ограничения общности, а bitcast и ptrtoint только подходящие под определённые шаблоны. В случае bitcast единственными пользователями должны бить интринсики lifetime.start/end. В случае ptrtoint фронтенд ispc вместо доступа к нулевому элементу структуры через getelementptr использует указатель на структуру. Данный подход необходимо было поддерживать, поэтому в анализе ptrtoint проверяется соответствие шаблону вычисления указателя из следующих инструкций: insertelement, shufflevector, add и read/write. В случае если результатом getelementptr является примитивный тип, то эта инструкция заменится на эквивалентную с другим операндом и новой цепочкой индексов. Если результатом getelementptr является поделённая структура, то будут сгенерированы столько новых getelementptr инструкций, на сколько структур поделилась исходная. На Рис.~\ref{fig:inst_proc} показан автомат обработки инструкций в модуле.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture} [node distance = 2.5cm, on grid]
        \node (AI) [state, initial] {$AI$};
        \node (GEP) [state, right = of AI,
                     accepting right,
                     accepting distance=1cm,
                     accepting text = {others}] {$GEP$};
        \node (PTI) [state, below right = of AI] {$PTI$};
        \node (offset) [state, right = of PTI] {$offset$};
        \node (mem) [state, right = of offset] {$mem$};
        \node (BC) [state, below = of PTI] {$bitcast$};
        \node (life) [state, right = of BC] {$lifetime$};
        
        \path [-stealth, thick]
          (AI) edge node {} (GEP)
          (AI) edge node {} (PTI)
          (AI) edge node {} (BC)
          
          (GEP) edge [loop above] node {поделённая структура} ()
          (GEP) edge node {} (PTI)
          
          (PTI) edge node {} (offset)
          (offset) edge node {} (mem)
          
          (BC) edge node {} (life);
    \end{tikzpicture}
    \caption{Автомат обработки инструкций.}
    \label{fig:inst_proc}
\end{figure}





%%
%%